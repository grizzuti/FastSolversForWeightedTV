var documenterSearchIndex = {"docs":
[{"location":"functions/#Main-functions","page":"Main functions","title":"Main functions","text":"","category":"section"},{"location":"functions/","page":"Main functions","title":"Main functions","text":"gradient_norm","category":"page"},{"location":"functions/#FastSolversForWeightedTV.gradient_norm","page":"Main functions","title":"FastSolversForWeightedTV.gradient_norm","text":"gradient_norm(p1, p2, n, h; weight=nothing, complex=false, gpu=false, options=exact_argmin())\n\nReturns the regularization function associated to the weighted gradient mixed norm g(mathbfu)=mathrmAnablamathbfu_p1p2.\n\nThe mixed norm is specified by p1 and p2. For p1=2, p2=1, and weight=nothing, for example, one gets conventional TV. Other supported options are p2=2 or p2=Inf.\n\nThe Cartesian grid geometry is determined by the grid size n and spacing h. For instance, in 3D, n=(64, 128, 256), h=(1f0, 2f0, 3f0).\n\nThe linear operator A is specified via the keyword weight. Note that this weight must be initialized via the tools contained in the package AbstractLinearOperators (see Section Getting started for an example).\n\nComplex or real inputs are handled via the keyword complex. Set complex=true for complex image input.\n\nFor sped-up computations, set gpu=true. Note that the input must also be a CuArray type, in this case.\n\nFor the evaluation of the associated proximal operator, one must specify a solver with the keyword options. Dedicated solvers are offered by the package AbstractProximableFunctions.jl (e.g. FISTA, see Section Getting started for some basic usage options).\n\n\n\n\n\n","category":"function"},{"location":"examples/#Getting-started","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"examples/#TV-vs-reference-guided-TV-denoising","page":"Getting started","title":"TV vs reference-guided TV denoising","text":"","category":"section"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"We briefly describe how to use the tools provided by this package. We focus, here, on a 3D TV-denoising example with GPU acceleration.","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"For starters, let's make sure to install all the needed packages! Besides, FastSolversForWeightedTV, we need AbstractLinearOperators and AbstractProximableFunctions that provide all the general utilities to specify the solvers needed for the computation of the proximal/projection operator. Type ] in the Julia REPL and","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"@(v1.8) pkg> https://github.com/grizzuti/AbstractLinearOperators.git, https://github.com/grizzuti/AbstractProximableFunctions.git, https://github.com/grizzuti/FastSolversForWeightedTV.git","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"For this tutorial, we also need CUDA, PyPlot, and TestImages. To install,","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"@(v1.8) pkg> add CUDA, TestImages, PyPlot","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"Here, we use PyPlot for image visualization, but many other packages may fit the bill.","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"To load the relevant modules:","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"# Package load\nusing LinearAlgebra, CUDA, TestImages, PyPlot\nusing AbstractProximableFunctions, FastSolversForWeightedTV","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"Let's load the 2D Shepp-Logan phantom and make a 3D volume out of it. Also let's contaminate the volume with some random noise:","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"# Prepare data\nn = (256, 256, 256)                                   # Image size\nx_clean = Float32.(TestImages.shepp_logan(n[1:2]...)) # 2D Shepp-Logan of size 256x256\nx_clean = repeat(x_clean; outer=(1,1,n[3]))           # 3D \"augmentation\"\nx_clean = CuArray(x_clean)                            # Move data to GPU\nx_clean = x_clean/norm(x_clean, Inf)                  # Normalization\nx_noisy = x_clean+0.1f0*CUDA.randn(Float32, n)        # Adding noise","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"Now that we prepared the noisy data, we define the regularization functional based on TV that we can use to clean up the noisy image. For that purpose:","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"h = (1f0, 1f0, 1f0)                                                     # Grid spacing\nL = 12f0                                                                # Spectral norm of the gradient operator\nopt = FISTA_options(L; Nesterov=true,\n                       niter=20,\n                       reset_counter=10,\n                       verbose=false)                                   # FISTA options\ng_TV  = gradient_norm(2, 1, n, h; complex=false, gpu=true, options=opt) # TV","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"To keep in mind: the spectral norm of the gradient operator must be known (but that's easy, e.g. L=4sum_i1h_i^2). In this example, the input image is real valued, hence complex=false. Also, note that we must specify a FISTA solver to use TV. In order to perform TV denoising, type","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"λ = 0.5f0*norm(x_clean-x_noisy)^2/g_TV(x_clean) # Denoising weight\nx_TV = prox(x_noisy, λ, g_TV)                   # TV denoising","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"We can get an even better result by using a reference volume to guide TV. The ideal reference is the ground-truth! So, for this time, let's cheat by setting:","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"η = 0.1f0*structural_mean(x_clean)                                                 # Stabilization term\nP = structural_weight(x_clean; η=η)                                                # Weight based on a given reference\ng_rTV  = gradient_norm(2, 1, n, h; weight=P, complex=false, gpu=true, options=opt) # Reference-guided TV","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"Denoise!","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"λ = 0.5f0*norm(x_clean-x_noisy)^2/g_rTV(x_clean) # Denoising weight\nx_rTV = prox(x_noisy, λ, g_rTV)                  # Reference-guided TV denoising","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"Finally, compare the different results:","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"x_clean = Array(x_clean) # Move to CPU\nx_noisy = Array(x_noisy) # Move to CPU\nx_TV = Array(x_TV)       # Move to CPU\nx_rTV = Array(x_rTV)     # Move to CPU\n\n# Plot\nfigure()\nsubplot(1, 4, 1)\ntitle(\"Noisy\")\nimshow(abs.(x_noisy[:,:,129]); vmin=0, vmax=1, cmap=\"gray\")\nsubplot(1, 4, 2)\ntitle(\"TV\")\nimshow(abs.(x_TV[:,:,129]); vmin=0, vmax=1, cmap=\"gray\")\nsubplot(1, 4, 3)\ntitle(\"rTV\")\nimshow(abs.(x_rTV[:,:,129]); vmin=0, vmax=1, cmap=\"gray\")\nsubplot(1, 4, 4)\ntitle(\"Ground-truth\")\nimshow(abs.(x_clean[:,:,129]); vmin=0, vmax=1, cmap=\"gray\")","category":"page"},{"location":"examples/#Proximal-vs-projection","page":"Getting started","title":"Proximal vs projection","text":"","category":"section"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"In inverse problems, deciding the weight lambda of the regularization term g is no trivial matter. For these reasons, sometime it is preferable to set hard constraints glevarepsilon. This package provides the utilities to compute projection operators (as defined in Section Proximal and projection operators), for example:","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"ε = 0.5f0*g_rTV(x_clean)             # Noise level\nx_rTV_proj = proj(x_noisy, ε, g_rTV) # Projection","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"Alternatively (in eye-candy fashion):","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"C = g_rTV ≤ 0.5f0             # Constraint set\nx_rTV_proj = proj(x_noisy, C) # Projection","category":"page"},{"location":"installation/#Installation-instructions","page":"Installation","title":"Installation instructions","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"In the Julia REPL, simply type ] and","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"(@v1.8) pkg> add https://github.com/grizzuti/FastSolversForWeightedTV.git","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"#Reference-guided-TV","page":"Introduction","title":"Reference-guided TV","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"FastSolversForWeightedTV.jl allows the computation of the proximal operator or projection operator associated to the reference-guided total variation regularization (TV) introduced in [1] (see also [2] for an application to motion correction in MRI). This implementation comprises both 2D and 3D, and supports GPU acceleration.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The definition of the reference-guided TV regularization is:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"mathrmTV(mathbfu mathbfv)=Pi(mathbfv)nablamathbfu_21=sum_i Pi(mathbfv)_inablamathbfu_i_2qquadPi(mathbfv)_i=mathrmI_dtimes d-hatnablamathbfv_i^asthatnablamathbfv_i","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Here, the reference image (2D/3D) is denoted by mathbfv, nabla is the discretized gradient operator, and the index i refers to the related grid point. mathrmI_dtimes d is the dtimes d identity matrix (where d=23, depending on the dimension of the problem). The normalized reference gradient field is defined by:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"hatnablamathbfv_i=dfracnablamathbfv_isqrtnablamathbfv_i_2^2+eta^2","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"where the constant eta0 stabilizes the division.","category":"page"},{"location":"#Proximal-and-projection-operators","page":"Introduction","title":"Proximal and projection operators","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The main functionalities provided by this package are related to the computation of the proximal and projection operators. For a generic convex functional g, the proximal operator is defined as","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"mathrmprox_lambdag(mathbfw)=argmin_mathbfudfrac12mathbfu-mathbfw^2+lambdag(mathbfu)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Similarly, the projection operator is defined as","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"mathrmproj_varepsilon g(mathbfw)=argmin_g(mathbfu)levarepsilondfrac12mathbfu-mathbfw^2","category":"page"},{"location":"#Related-publications","page":"Introduction","title":"Related publications","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Ehrhardt, M. J., and Betcke, M. M., (2015). Multi-Contrast MRI Reconstruction with Structure-Guided Total Variation (https://arxiv.org/abs/1511.06631), SIAM J. IMAGING SCIENCES, 9(3), 1084-1106, doi:10.1137/15M1047325\nRizzuti, G., Sbrizzi, A., and van Leeuwen, T., (2022). Joint Retrospective Motion Correction and Reconstruction for Brain MRI With a Reference Contrast, IEEE Transaction on Computational Imaging, 8, 490-504, doi:10.1109/TCI.2022.3183383","category":"page"}]
}
