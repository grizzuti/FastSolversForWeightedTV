var documenterSearchIndex = {"docs":
[{"location":"functions/#Main-functions","page":"Main functions","title":"Main functions","text":"","category":"section"},{"location":"functions/","page":"Main functions","title":"Main functions","text":"gradient_norm","category":"page"},{"location":"functions/#FastSolversForWeightedTV.gradient_norm","page":"Main functions","title":"FastSolversForWeightedTV.gradient_norm","text":"gradient_norm(p1, p2, n, h; weight=nothing,\n                            complex=false,\n                            gpu=false,\n                            options=exact_argmin())\n\nReturns the regularization function associated to the weighted gradient mixed norm g(mathbfu)=mathrmAnablamathbfu_p1p2.\n\nThe mixed norm is specified by p1 and p2. For p1=2, p2=1, and weight=nothing, for example, one gets conventional TV. Other supported options are p2=2 or p2=Inf.\n\nThe Cartesian grid geometry is determined by the grid size n and spacing h. For instance, in 3D, n=(64, 128, 256), h=(1f0, 2f0, 3f0).\n\nThe linear operator A is specified via the keyword weight. Note that this weight must be initialized via the tools contained in the package AbstractLinearOperators (see Section Getting started for an example).\n\nComplex or real inputs are handled via the keyword complex. Set complex=true for complex image input.\n\nFor sped-up computations, set gpu=true. Note that the input must also be a CuArray type, in this case.\n\nFor the evaluation of the associated proximal operator, one must specify a solver with the keyword options. Dedicated solvers are offered by the package AbstractProximableFunctions.jl (e.g. FISTA, see Section Getting started for some basic usage options).\n\n\n\n\n\n","category":"function"},{"location":"functions/#Important-utilities-from-ancillary-packages","page":"Main functions","title":"Important utilities from ancillary packages","text":"","category":"section"},{"location":"functions/","page":"Main functions","title":"Main functions","text":"We list the most important utilities from AbstractProximableFunctions that are meant to be routinely combined with FastSolversForWeightedTV, such as tools to define iterative solver options, and functions to call the proximal/projection operators.","category":"page"},{"location":"functions/","page":"Main functions","title":"Main functions","text":"prox(y::AbstractArray{CT,N}, λ::T, g::AbstractProximableFunction{CT,N}) where {T<:Real,N,CT<:RealOrComplex{T}}","category":"page"},{"location":"functions/#AbstractProximableFunctions.prox-Union{Tuple{CT}, Tuple{N}, Tuple{T}, Tuple{AbstractArray{CT, N}, T, AbstractProximableFunction{CT, N}}} where {T<:Real, N, CT<:Union{Complex{T}, T}}","page":"Main functions","title":"AbstractProximableFunctions.prox","text":"prox(y::AbstractArray{CT,N}, λ::T, g::AbstractProximableFunction{CT,N}) where {T<:Real,N,CT<:RealOrComplex{T}}\n\nComputes the proximal operator mathrmprox_lambdag(mathbfy).\n\n\n\n\n\n","category":"method"},{"location":"functions/","page":"Main functions","title":"Main functions","text":"prox(y::AbstractArray{CT,N}, λ::T, g::AbstractProximableFunction{CT,N}, options::AbstractArgminOptions) where {T<:Real,N,CT<:RealOrComplex{T}}","category":"page"},{"location":"functions/#AbstractProximableFunctions.prox-Union{Tuple{CT}, Tuple{N}, Tuple{T}, Tuple{AbstractArray{CT, N}, T, AbstractProximableFunction{CT, N}, AbstractArgminOptions}} where {T<:Real, N, CT<:Union{Complex{T}, T}}","page":"Main functions","title":"AbstractProximableFunctions.prox","text":"prox(y::AbstractArray{CT,N}, λ::T, g::AbstractProximableFunction{CT,N}, options::AbstractArgminOptions) where {T<:Real,N,CT<:RealOrComplex{T}}\n\nComputes the proximal operator with specified options.\n\nSee prox(y::AbstractArray{CT,N}, λ::T, g::AbstractProximableFunction{CT,N}) where {T<:Real,N,CT<:RealOrComplex{T}}\n\n\n\n\n\n","category":"method"},{"location":"functions/","page":"Main functions","title":"Main functions","text":"proj(y::AbstractArray{CT,N}, λ::T, g::AbstractProximableFunction{CT,N}) where {T<:Real,N,CT<:RealOrComplex{T}}","category":"page"},{"location":"functions/#AbstractProximableFunctions.proj-Union{Tuple{CT}, Tuple{N}, Tuple{T}, Tuple{AbstractArray{CT, N}, T, AbstractProximableFunction{CT, N}}} where {T<:Real, N, CT<:Union{Complex{T}, T}}","page":"Main functions","title":"AbstractProximableFunctions.proj","text":"proj(y::AbstractArray{CT,N}, ε::T, g::AbstractProximableFunction{CT,N}) where {T<:Real,N,CT<:RealOrComplex{T}}\n\nComputes the projection operator mathrmproj_lambdag(mathbfy).\n\n\n\n\n\n","category":"method"},{"location":"functions/","page":"Main functions","title":"Main functions","text":"proj(y::AbstractArray{CT,N}, λ::T, g::AbstractProximableFunction{CT,N}, options::AbstractArgminOptions) where {T<:Real,N,CT<:RealOrComplex{T}}","category":"page"},{"location":"functions/#AbstractProximableFunctions.proj-Union{Tuple{CT}, Tuple{N}, Tuple{T}, Tuple{AbstractArray{CT, N}, T, AbstractProximableFunction{CT, N}, AbstractArgminOptions}} where {T<:Real, N, CT<:Union{Complex{T}, T}}","page":"Main functions","title":"AbstractProximableFunctions.proj","text":"proj(y::AbstractArray{CT,N}, ε::T, g::AbstractProximableFunction{CT,N}, options::AbstractArgminOptions) where {T<:Real,N,CT<:RealOrComplex{T}}\n\nComputes the projection operator with specified options.\n\nSee proj(y::AbstractArray{CT,N}, ε::T, g::AbstractProximableFunction{CT,N}) where {T<:Real,N,CT<:RealOrComplex{T}}\n\n\n\n\n\n","category":"method"},{"location":"functions/","page":"Main functions","title":"Main functions","text":"exact_argmin","category":"page"},{"location":"functions/#AbstractProximableFunctions.exact_argmin","page":"Main functions","title":"AbstractProximableFunctions.exact_argmin","text":"exact_argmin()\n\nReturns exact optimization options for the computation of proximal/projection operators. It might results in an error if the regularization functional does not implement analytically-defined proximal/projection operators (e.g. TV!).\n\n\n\n\n\n","category":"function"},{"location":"functions/","page":"Main functions","title":"Main functions","text":"FISTA_options","category":"page"},{"location":"functions/#AbstractProximableFunctions.FISTA_options","page":"Main functions","title":"AbstractProximableFunctions.FISTA_options","text":"FISTA_options(L; Nesterov=true,\n                 reset_counter=nothing,\n                 niter=nothing,\n                 verbose=false,\n                 fun_history=false)\n\nReturns FISTA iterative solver options for the general optimization problem:\n\nmin_mathbfxf(mathbfx)+g(mathbfx)\n\nwhere g is a \"proximable\" function. It can be used to define options for the proximal or projection operators.\n\nThe parameter L ideally should be chosen as LgemathrmLipnabla f (=Lipschitz constant of the gradient) and is problem specific.\n\nNesterov acceleration is set by Nesterov=true, while reset_counter is the number of iteration after which the Nesterov momentum is reset. The total number of iterations is determined by niter.\n\nFor debugging, set verbose=true and/or fun_history=true (the latter allows storing the history of f(mathbfx), which can be retrieved by fun_history(options) after minimization).\n\nImportant note\n\nWhen setting the options for proximal or projection operators, follow the recommendations for each specific proximal function on how to choose L. The underlying optimization may be based on algebraic reformulations of the optimization problem min_mathbfx12mathbfx-mathbfy^2+lambdag(mathbfx), so the assumption that f(mathbfx)=12mathbfx-mathbfy^2 is not generally correct. This note is relevant when computing the proximal operator of WeightedProximalFunction's for which the problem min_mathbfx12mathbfx-mathbfy^2+lambdag(Amathbfx) is transformed to min_mathbfp12lambda A^*mathbfp-mathbfy^2+lambda g^*(mathbfp). The Lipschitz constant in this case should be lambda^2rho(A). For convenience of use, however, the Lipschitz constant is expected to be just rho(A).\n\n\n\n\n\n","category":"function"},{"location":"examples/#Getting-started","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"examples/#TV-vs-reference-guided-TV-denoising","page":"Getting started","title":"TV vs reference-guided TV denoising","text":"","category":"section"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"We briefly describe how to use the tools provided by this package. We focus, here, on a 3D TV-denoising example with GPU acceleration.","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"For starters, let's make sure that all the needed packages are installed! Please, follow the instructions in Section Installation instructions. For this tutorial, we also need CUDA, PyPlot, and TestImages. To install, Type ] in the Julia REPL and","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"@(v1.8) pkg> add CUDA, TestImages, PyPlot","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"Here, we use PyPlot for image visualization, but many other packages may fit the bill.","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"To load the relevant modules:","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"# Package load\nusing LinearAlgebra, CUDA, TestImages, PyPlot\nusing AbstractProximableFunctions, FastSolversForWeightedTV","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"Let's load the 2D Shepp-Logan phantom and make a 3D volume out of it. Also let's contaminate the volume with some random noise:","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"# Prepare data\nn = (256, 256, 256)                                   # Image size\nx_clean = Float32.(TestImages.shepp_logan(n[1:2]...)) # 2D Shepp-Logan of size 256x256\nx_clean = repeat(x_clean; outer=(1,1,n[3]))           # 3D \"augmentation\"\nx_clean = CuArray(x_clean)                            # Move data to GPU\nx_clean = x_clean/norm(x_clean, Inf)                  # Normalization\nx_noisy = x_clean+0.1f0*CUDA.randn(Float32, n)        # Adding noise","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"Now that we prepared the noisy data, we define the regularization functional based on TV that we can use to clean up the noisy image. For that purpose:","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"# Regularization\nh = (1f0, 1f0, 1f0)                                                     # Grid spacing\nL = 12f0                                                                # Spectral norm of the gradient operator\nopt = FISTA_options(L; Nesterov=true,\n                       niter=20,\n                       reset_counter=10,\n                       verbose=false)                                   # FISTA options\ng_TV  = gradient_norm(2, 1, n, h; complex=false, gpu=true, options=opt) # TV","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"To keep in mind: the spectral norm of the gradient operator must be known (but that's easy, e.g. L=4sum_i1h_i^2). In this example, the input image is real valued, hence complex=false. Also, note that we must specify a FISTA solver to use TV. In order to perform TV denoising, type","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"# Denoising\nλ = 0.5f0*norm(x_clean-x_noisy)^2/g_TV(x_clean) # Denoising weight\nx_TV = prox(x_noisy, λ, g_TV)                   # TV denoising","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"We can get an even better result by using a reference volume to guide TV. The ideal reference is the ground-truth! So, for this time, let's cheat by setting:","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"# Reference-guided regularization\nη = 0.1f0*structural_mean(x_clean)                                                 # Stabilization term\nP = structural_weight(x_clean; η=η)                                                # Weight based on a given reference\ng_rTV  = gradient_norm(2, 1, n, h; weight=P, complex=false, gpu=true, options=opt) # Reference-guided TV","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"Denoise!","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"# Denoising (structure-guided)\nλ = 0.5f0*norm(x_clean-x_noisy)^2/g_rTV(x_clean) # Denoising weight\nx_rTV = prox(x_noisy, λ, g_rTV)                  # Reference-guided TV denoising","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"In inverse problems, deciding the weight lambda of the regularization term g is no trivial matter. For these reasons, sometime it is preferable to set hard constraints glevarepsilon. This package provides the utilities to compute projection operators (as defined in Section Proximal and projection operators), for example:","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"# Denoising (structure-guided projection)\nε = 0.5f0*g_rTV(x_clean)             # Noise level\nx_rTV_proj = proj(x_noisy, ε, g_rTV) # Projection\n\n# Equivalently: Denoising (structure-guided projection)\nC = g_rTV ≤ ε                 # Constraint set\nx_rTV_proj = proj(x_noisy, C) # Projection","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"Finally, compare the different results:","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"# Move data back to CPU\nx_clean = Array(x_clean)\nx_noisy = Array(x_noisy)\nx_TV = Array(x_TV)\nx_rTV = Array(x_rTV)\n\n# Plot\nfigure()\nsubplot(1, 4, 1)\ntitle(\"Noisy\")\nimshow(abs.(x_noisy[:,:,129]); vmin=0, vmax=1, cmap=\"gray\")\nsubplot(1, 4, 2)\ntitle(\"TV\")\nimshow(abs.(x_TV[:,:,129]); vmin=0, vmax=1, cmap=\"gray\")\nsubplot(1, 4, 3)\ntitle(\"rTV\")\nimshow(abs.(x_rTV[:,:,129]); vmin=0, vmax=1, cmap=\"gray\")\nsubplot(1, 4, 4)\ntitle(\"Ground-truth\")\nimshow(abs.(x_clean[:,:,129]); vmin=0, vmax=1, cmap=\"gray\")","category":"page"},{"location":"installation/#Installation-instructions","page":"Installation","title":"Installation instructions","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"In the Julia REPL, simply type ] and","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"(@v1.8) pkg> add https://github.com/grizzuti/AbstractLinearOperators.git, add https://github.com/grizzuti/AbstractProximableFunctions.git, add https://github.com/grizzuti/FastSolversForWeightedTV.git","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"The packages AbstractLinearOperators and AbstractProximableFunctions have to be explicitly installed since they are unregistered at the moment.","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"#Reference-guided-TV","page":"Introduction","title":"Reference-guided TV","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"FastSolversForWeightedTV.jl allows the computation of the proximal operator or projection operator associated to the reference-guided total variation regularization (TV) introduced in [1] (see also [2] for an application to motion correction in MRI). This implementation comprises both 2D and 3D, and supports GPU acceleration.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The definition of the reference-guided TV regularization is:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"mathrmTV(mathbfu mathbfv)=Pi(mathbfv)nablamathbfu_21=sum_i Pi(mathbfv)_inablamathbfu_i_2qquadPi(mathbfv)_i=mathrmI_dtimes d-hatnablamathbfv_i^mathrmHhatnablamathbfv_i","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Here, the reference image (2D/3D) is denoted by mathbfv, nabla is the discretized gradient operator, and the index i refers to the related grid point. mathrmI_dtimes d is the dtimes d identity matrix (where d=23, depending on the dimension of the problem). The normalized reference gradient field is defined by:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"hatnablamathbfv_i=dfracnablamathbfv_isqrtnablamathbfv_i_2^2+eta^2","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"where the constant eta0 stabilizes the division.","category":"page"},{"location":"#Proximal-and-projection-operators","page":"Introduction","title":"Proximal and projection operators","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The main functionalities provided by this package are related to the computation of the proximal and projection operators. For a generic convex functional g, the proximal operator is defined as","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"mathrmprox_lambdag(mathbfw)=argmin_mathbfudfrac12mathbfu-mathbfw^2+lambdag(mathbfu)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Similarly, the projection operator is defined as","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"mathrmproj_varepsilon g(mathbfw)=argmin_g(mathbfu)levarepsilondfrac12mathbfu-mathbfw^2","category":"page"},{"location":"#Related-publications","page":"Introduction","title":"Related publications","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Ehrhardt, M. J., and Betcke, M. M., (2015). Multi-Contrast MRI Reconstruction with Structure-Guided Total Variation (https://arxiv.org/abs/1511.06631), SIAM J. IMAGING SCIENCES, 9(3), 1084-1106, doi:10.1137/15M1047325\nRizzuti, G., Sbrizzi, A., and van Leeuwen, T., (2022). Joint Retrospective Motion Correction and Reconstruction for Brain MRI With a Reference Contrast, IEEE Transaction on Computational Imaging, 8, 490-504, doi:10.1109/TCI.2022.3183383","category":"page"}]
}
